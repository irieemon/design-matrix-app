import { useEffect, useRef, useCallback, useState } from 'react'\n\n// Animation configurations\nexport interface AnimationConfig {\n  duration?: number\n  easing?: string\n  delay?: number\n  iterations?: number\n  direction?: 'normal' | 'reverse' | 'alternate' | 'alternate-reverse'\n  fillMode?: 'none' | 'forwards' | 'backwards' | 'both'\n}\n\nexport interface SpringConfig {\n  tension?: number\n  friction?: number\n  mass?: number\n  velocity?: number\n}\n\nexport interface ParticleConfig {\n  count?: number\n  colors?: string[]\n  shapes?: ('circle' | 'square' | 'triangle')[]\n  duration?: number\n  spread?: number\n  origin?: { x: number; y: number }\n}\n\n// Predefined premium animations\nconst PREMIUM_ANIMATIONS = {\n  // Entrance animations\n  fadeInUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0)' }\n    ],\n    config: { duration: 600, easing: 'cubic-bezier(0.16, 1, 0.3, 1)' }\n  },\n  \n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(30px)' },\n      { opacity: 1, transform: 'translateX(0)' }\n    ],\n    config: { duration: 500, easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' }\n  },\n  \n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.9)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    config: { duration: 400, easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)' }\n  },\n  \n  // Interaction animations\n  bounce: {\n    keyframes: [\n      { transform: 'scale(1)' },\n      { transform: 'scale(1.05)' },\n      { transform: 'scale(0.95)' },\n      { transform: 'scale(1)' }\n    ],\n    config: { duration: 600, easing: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)' }\n  },\n  \n  pulse: {\n    keyframes: [\n      { transform: 'scale(1)', opacity: 1 },\n      { transform: 'scale(1.1)', opacity: 0.8 },\n      { transform: 'scale(1)', opacity: 1 }\n    ],\n    config: { duration: 1000, easing: 'ease-in-out', iterations: Infinity }\n  },\n  \n  shake: {\n    keyframes: [\n      { transform: 'translateX(0)' },\n      { transform: 'translateX(-5px)' },\n      { transform: 'translateX(5px)' },\n      { transform: 'translateX(-5px)' },\n      { transform: 'translateX(0)' }\n    ],\n    config: { duration: 500, easing: 'ease-in-out' }\n  },\n  \n  // Success animations\n  checkmark: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0) rotate(45deg)' },\n      { opacity: 1, transform: 'scale(1.2) rotate(45deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(45deg)' }\n    ],\n    config: { duration: 600, easing: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)' }\n  },\n  \n  // Loading animations\n  shimmer: {\n    keyframes: [\n      { transform: 'translateX(-100%)' },\n      { transform: 'translateX(100%)' }\n    ],\n    config: { duration: 1500, easing: 'ease-in-out', iterations: Infinity }\n  },\n  \n  // Hover effects\n  liftUp: {\n    keyframes: [\n      { transform: 'translateY(0) scale(1)', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' },\n      { transform: 'translateY(-2px) scale(1.02)', boxShadow: '0 8px 25px rgba(0,0,0,0.15)' }\n    ],\n    config: { duration: 200, easing: 'ease-out', fillMode: 'forwards' }\n  },\n  \n  // Attention seekers\n  wiggle: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(5deg)' },\n      { transform: 'rotate(-5deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    config: { duration: 500, easing: 'ease-in-out' }\n  }\n}\n\nexport const usePremiumAnimations = () => {\n  const [isAnimationEnabled, setIsAnimationEnabled] = useState(true)\n  const animationRefs = useRef<Map<string, Animation>>(new Map())\n  const observerRef = useRef<IntersectionObserver | null>(null)\n\n  // Check user's animation preferences\n  useEffect(() => {\n    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    setIsAnimationEnabled(!prefersReducedMotion)\n  }, [])\n\n  // Animate element with predefined animation\n  const animate = useCallback((element: HTMLElement, animationName: keyof typeof PREMIUM_ANIMATIONS, customConfig?: AnimationConfig) => {\n    if (!isAnimationEnabled || !element) return null\n\n    const animation = PREMIUM_ANIMATIONS[animationName]\n    if (!animation) {\n      console.warn(`Animation '${animationName}' not found`)\n      return null\n    }\n\n    const config = { ...animation.config, ...customConfig }\n    const webAnimation = element.animate(animation.keyframes, config)\n    \n    // Store animation reference\n    const animationId = `${animationName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n    animationRefs.current.set(animationId, webAnimation)\n\n    // Cleanup when animation finishes\n    webAnimation.addEventListener('finish', () => {\n      animationRefs.current.delete(animationId)\n    })\n\n    return webAnimation\n  }, [isAnimationEnabled])\n\n  // Custom keyframe animation\n  const animateCustom = useCallback((element: HTMLElement, keyframes: Keyframe[], config: AnimationConfig = {}) => {\n    if (!isAnimationEnabled || !element) return null\n\n    const defaultConfig = {\n      duration: 300,\n      easing: 'ease',\n      fillMode: 'both' as const\n    }\n\n    const webAnimation = element.animate(keyframes, { ...defaultConfig, ...config })\n    \n    const animationId = `custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n    animationRefs.current.set(animationId, webAnimation)\n\n    webAnimation.addEventListener('finish', () => {\n      animationRefs.current.delete(animationId)\n    })\n\n    return webAnimation\n  }, [isAnimationEnabled])\n\n  // Spring-based animation (simplified)\n  const animateSpring = useCallback((element: HTMLElement, targetState: Partial<CSSStyleDeclaration>, springConfig: SpringConfig = {}) => {\n    if (!isAnimationEnabled || !element) return null\n\n    const { tension = 170, friction = 26, mass = 1 } = springConfig\n    \n    // Convert spring config to CSS transition\n    const dampingRatio = friction / (2 * Math.sqrt(mass * tension))\n    const naturalFrequency = Math.sqrt(tension / mass)\n    const duration = dampingRatio < 1 ? \n      (4 / (naturalFrequency * Math.sqrt(1 - dampingRatio * dampingRatio))) * 1000 :\n      (4 / naturalFrequency) * 1000\n\n    const easing = dampingRatio >= 1 ? 'ease-out' : 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n\n    // Apply styles with transition\n    element.style.transition = `all ${duration}ms ${easing}`\n    Object.assign(element.style, targetState)\n\n    // Reset transition after animation\n    setTimeout(() => {\n      element.style.transition = ''\n    }, duration)\n\n    return { duration, easing }\n  }, [isAnimationEnabled])\n\n  // Stagger animation for multiple elements\n  const staggerAnimation = useCallback((elements: HTMLElement[], animationName: keyof typeof PREMIUM_ANIMATIONS, staggerDelay = 100) => {\n    if (!isAnimationEnabled) return []\n\n    return elements.map((element, index) => {\n      return animate(element, animationName, { delay: index * staggerDelay })\n    }).filter(Boolean)\n  }, [animate, isAnimationEnabled])\n\n  // Parallax scroll effect\n  const createParallaxEffect = useCallback((element: HTMLElement, speed = 0.5) => {\n    if (!isAnimationEnabled) return () => {}\n\n    const handleScroll = () => {\n      const scrolled = window.pageYOffset\n      const rate = scrolled * -speed\n      element.style.transform = `translateY(${rate}px)`\n    }\n\n    window.addEventListener('scroll', handleScroll, { passive: true })\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll)\n    }\n  }, [isAnimationEnabled])\n\n  // Intersection observer animations\n  const animateOnScroll = useCallback((element: HTMLElement, animationName: keyof typeof PREMIUM_ANIMATIONS, threshold = 0.1) => {\n    if (!isAnimationEnabled) return () => {}\n\n    if (!observerRef.current) {\n      observerRef.current = new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            const animationName = entry.target.getAttribute('data-animation') as keyof typeof PREMIUM_ANIMATIONS\n            if (animationName) {\n              animate(entry.target as HTMLElement, animationName)\n            }\n          }\n        })\n      }, { threshold })\n    }\n\n    element.setAttribute('data-animation', animationName)\n    observerRef.current.observe(element)\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.unobserve(element)\n      }\n    }\n  }, [animate, isAnimationEnabled])\n\n  // Particle burst effect\n  const createParticleBurst = useCallback((element: HTMLElement, config: ParticleConfig = {}) => {\n    if (!isAnimationEnabled) return\n\n    const {\n      count = 10,\n      colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'],\n      shapes = ['circle'],\n      duration = 1000,\n      spread = 100,\n      origin = { x: 0.5, y: 0.5 }\n    } = config\n\n    const rect = element.getBoundingClientRect()\n    const container = document.createElement('div')\n    container.style.cssText = `\n      position: fixed;\n      top: ${rect.top + rect.height * origin.y}px;\n      left: ${rect.left + rect.width * origin.x}px;\n      pointer-events: none;\n      z-index: 9999;\n    `\n    document.body.appendChild(container)\n\n    for (let i = 0; i < count; i++) {\n      const particle = document.createElement('div')\n      const color = colors[Math.floor(Math.random() * colors.length)]\n      const shape = shapes[Math.floor(Math.random() * shapes.length)]\n      const size = Math.random() * 8 + 4\n      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5\n      const velocity = Math.random() * spread + 50\n      const x = Math.cos(angle) * velocity\n      const y = Math.sin(angle) * velocity\n\n      particle.style.cssText = `\n        position: absolute;\n        width: ${size}px;\n        height: ${size}px;\n        background: ${color};\n        border-radius: ${shape === 'circle' ? '50%' : '0'};\n        transform: ${shape === 'triangle' ? 'rotate(45deg)' : 'none'};\n      `\n\n      container.appendChild(particle)\n\n      // Animate particle\n      particle.animate([\n        { \n          transform: `translate(0, 0) scale(1)`,\n          opacity: 1\n        },\n        { \n          transform: `translate(${x}px, ${y}px) scale(0)`,\n          opacity: 0\n        }\n      ], {\n        duration: duration + Math.random() * 500,\n        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n      })\n    }\n\n    // Cleanup\n    setTimeout(() => {\n      document.body.removeChild(container)\n    }, duration + 500)\n  }, [isAnimationEnabled])\n\n  // Cleanup all animations\n  const cleanup = useCallback(() => {\n    animationRefs.current.forEach(animation => {\n      animation.cancel()\n    })\n    animationRefs.current.clear()\n\n    if (observerRef.current) {\n      observerRef.current.disconnect()\n    }\n  }, [])\n\n  // Auto cleanup on unmount\n  useEffect(() => {\n    return cleanup\n  }, [cleanup])\n\n  return {\n    animate,\n    animateCustom,\n    animateSpring,\n    staggerAnimation,\n    createParallaxEffect,\n    animateOnScroll,\n    createParticleBurst,\n    cleanup,\n    isAnimationEnabled,\n    setIsAnimationEnabled\n  }\n}"